import struct
import time, datetime
import os
import string
import sqlite3
import threading, thread
import bluetooth._bluetooth as bluez


# bluez functions, contstants can be found in bluez C source code in different files (lib/hci.h, lib/hci.c)
# bluetooth._bluetooth = bluetooth.so shared object in: /usr/lib/python2.7/dist-packages/bluetooth/_bluetooth

# Check Bluetooth specification (v4.2) Page 1271, Vol 2, Part E, section 7.8 LE Controller Commands
OGF_LE_CTL=0x08 # LE Controller Commands Group Code
OCF_LE_SET_SCAN_PARAMETERS=0x000B  # LE Set Scan Parameters Command -> Page 1286, Vol 2, Part E, Section: 7.8.10
OCF_LE_SET_SCAN_ENABLE=0x000C      # LE Set Scan Enable Command

#Check Bluetooth specification (v4.2) Page 1241, Vol 2, Part E, section 7.7.65.2 LE Advertising Report Event
LE_META_EVENT = 0x3E # event type for all LE event -> encapsulate all LE Controller speicific events
EVT_LE_ADVERTISING_REPORT=0x02 # subevent of LE_META_EVENT
# Advertisment event types
ADV_IND=0x00
ADV_DIRECT_IND=0x01
ADV_SCAN_IND=0x02
ADV_NONCONN_IND=0x03
ADV_SCAN_RSP=0x04

#Generated Event format (LE Advertising Report Event) by the controller for the host after an incoming Advertising packet
#Check Bluetooth Specification (v4.2), Vol 2, Part E, 5.4.4 HCI Event Packet (Page 786) + LE Advertising Report Event parameters (Page 1241)
#In case of 1 generated report/responses:
#1.byte : Packet type = HCI Event Packet = 0x04
#2.byte : Event Code = 0x3E - event type for all LE event -> encapsulate all LE Controller speicific events
#3.byte : Parameter Total Length
#4.byte : Subevent Code = 0x02
#5.byte : Number of responses = 0x01-0x19
#6.byte : Event Type: Non Connectable unidirected advertising = 0x03
#7.byte : Address Type
#8-13   : Address
#14.byte: Length of data (per reports)
#15-45  : Maximum 31 bytes of Data
#46.byte: RSSI in dBm

def process_BLE_packet(packet):
    Check_Sum_Genarated = 0
    j = 0
    
    Packet_type,Event_Code,Parameter_Total_Length,Subevent_Code = struct.unpack("BBBB",packet[0:4])
          
    if((Packet_type == 0x04) & (Event_Code == 0x3E) & (Subevent_Code == 0x02)): 

        try:
            Code = ''.join(struct.unpack("sss",packet[14:17]))  # string.join concatenates elements where the seperator will be the calling string between the elements
                
        except:
            # This is needed because if a BLE device advertises itself, but does not have data part, the previos command drops an exception
            return 0
        
        if(Code == "SUP"): #Also need to check the checksum from the message
                
            try:          
                Check_Sum_from_Packet,RSSI = struct.unpack("Bb",packet[24:26])          
                Plate_Number = ''.join(struct.unpack("sssssss",packet[17:24]))
            except:
                return 0
                
            # Calculate the "special" checksum generated by BLE TAG for further security 
            for i in range(0,7):
                Check_Sum_Genarated ^= ord(Plate_Number[i]) ^ ord(Code[j]) 
                if(j == 2): 
                    j = 0    
                else:
                    j = j+1
                        
            Code = ''               
            if(Check_Sum_Genarated == Check_Sum_from_Packet):  #Check the generated checksum
                # The averaging here is good only if 1 BLE TAG sending information
                # The formula used for distance calculation is not reliable, need to find a better one
                #print "RSSI: " + str(RSSI) + "counter: " + str(counter)
                
                #print "RSSI average in dBm= ",RSSI_average
                distance = float(10**((-68-float(RSSI)) / (10 * 1.6)))  # Needs to be rethink!!!!
                #print "TAG: " + str(Plate_Number) + " FOUND: " + str(float(RSSI)) + " At distance: " + str(distance)  
                return (None,str(Plate_Number),distance) #don't forget to change the distance value!!!!  
    return 0

def update_detected_tags(entry):
    #block doubled access to the database
    database = sqlite3.connect("Car_database.db")
    cursor = database.cursor()
    cursor.executemany("INSERT into Detected_tags VALUES(?,?,?)",entry )
    database.commit()   
    database.close()
    
#Check Bluetooth specification (4.2) page 1289, Vol 2, Part E, Section: 7.8.11 - LE Set Scan Enable Command
def hci_enable_le_scan(sock):
    cmd_pkt = struct.pack("<BB", 0x01, 0x00) # Last parameter: duplicate filtering: 0x00 - disabled
    bluez.hci_send_cmd(sock, OGF_LE_CTL, OCF_LE_SET_SCAN_ENABLE, cmd_pkt)
    print "...sent scan enable"
    

def hci_le_set_scan_parameters(sock):
    print "...setting up scan"  
    # Check Bluetooth specification (4.2) Page 1286, Vol 2, Part E, Section: 7.8.10 - LE Set Scan Parameters Command
    OWN_ADDR_TYPE = 0x00 #Own Address type: what to put in scan request packet 0x00 = Public Device Address, 0x01 - Random device Address
    SCAN_TYPE = 0x00 #0x00 = Passive scanning, 0x01 = Active scanning
    INTERVAL = 0x10 # Time between 2 scanning: value * 0.625 ms
    WINDOW = 0x10 # Duration of LE scan : value * 0.625 ms
    FILTER = 0x00 # all advertisements, not just whitelisted devices
    # interval and window are uint_16, so we pad them with 0x0
    cmd_pkt = struct.pack("<BBBBBBB", SCAN_TYPE, 0x0, INTERVAL, 0x0, WINDOW, OWN_ADDR_TYPE, FILTER)
    #print "packed up: ", cmd_pkt
    bluez.hci_send_cmd(sock, OGF_LE_CTL, OCF_LE_SET_SCAN_PARAMETERS, cmd_pkt)
    print "...sent scan parameters command"