/* Process model C form file: pm_utp_process_old.pr.c */
/* Portions of this file copyright 1986-2012 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from pm_utp_process_old.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char pm_utp_process_old_pr_c [] = "MIL_3_Tfile_Hdr_ 171A 30A op_runsim_dev 7 554E1ACD 554E1ACD 1 FTNK-B0013 s146147 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 2b74 2                                                                                                                                                                                                                                                                                                                                                                                                 ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#define PowerUp (op_intrpt_type() == OPC_INTRPT_BEGSIM) 
#define PacketArrival (op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm()==PckStream) 
#define AppDataArrival (op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm()==AppDataStream)
#define TimerOver (op_intrpt_type() == OPC_INTRPT_SELF) 
#define DataPacketArrival (PacketArrival && pkt_type==DATA_PKT)
#define AckPacketArrival (PacketArrival && pkt_type==ACK)
#define FastRetrans (ack_num<TrWaitAckSeq  && ack_seq_cnt>=4)
/* Macro for determining the number of packets in the queue */ 
#define QSize (op_subq_stat(0, OPC_QSTAT_PKSIZE))
#define ACK 1
#define DATA_PKT 0
#define DEST_PORT_TCP_APP 0

#define SLOW_START 0
#define CONG_AV 1

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	int	                    		PckStream                                       ;
	int	                    		AppDataStream                                   ;
	int	                    		SinkStream                                      ;
	int	                    		TransStream                                     ;
	int	                    		RecNextPckSeq                                   ;
	int	                    		TrNextPckSeq                                    ;
	int	                    		TrWaitAckSeq                                    ;
	Stathandle	             		rtt_stat_hndl                                   ;
	double	                 		retr_per_pkt                                    ;
	double	                 		TimeOutTimer                                    ;
	Evhandle	               		Timer                                           ;
	Boolean	                		DataPktArr                                      ;
	int	                    		TrPckSeq                                        ;
	Stathandle	             		retr_hndl                                       ;
	double	                 		retr                                            ;
	int	                    		new_variable                                    ;
	int	                    		TrNextPckAck                                    ;
	int	                    		TrPckAck                                        ;
	int	                    		cwnd                                            ;
	int	                    		cwnd_start_seq                                  ;
	int	                    		ack_seq_cnt                                     ;
	List*	                  		HandlesList                                     ;
	int	                    		RecNextAckNum                                   ;
	int	                    		MSS                                             ;
	int	                    		pkts_in_flight                                  ;
	int	                    		cwnd_thr                                        ;
	int	                    		cong_flag                                       ;
	double	                 		SRTT                                            ;
	double	                 		RTT                                             ;
	double	                 		SDEV                                            ;
	List*	                  		RTTList                                         ;
	double	                 		Retr_Cnt_Ack                                    ;
	int	                    		fast_retr_flag                                  ;
	} pm_utp_process_old_state;

#define PckStream               		op_sv_ptr->PckStream
#define AppDataStream           		op_sv_ptr->AppDataStream
#define SinkStream              		op_sv_ptr->SinkStream
#define TransStream             		op_sv_ptr->TransStream
#define RecNextPckSeq           		op_sv_ptr->RecNextPckSeq
#define TrNextPckSeq            		op_sv_ptr->TrNextPckSeq
#define TrWaitAckSeq            		op_sv_ptr->TrWaitAckSeq
#define rtt_stat_hndl           		op_sv_ptr->rtt_stat_hndl
#define retr_per_pkt            		op_sv_ptr->retr_per_pkt
#define TimeOutTimer            		op_sv_ptr->TimeOutTimer
#define Timer                   		op_sv_ptr->Timer
#define DataPktArr              		op_sv_ptr->DataPktArr
#define TrPckSeq                		op_sv_ptr->TrPckSeq
#define retr_hndl               		op_sv_ptr->retr_hndl
#define retr                    		op_sv_ptr->retr
#define new_variable            		op_sv_ptr->new_variable
#define TrNextPckAck            		op_sv_ptr->TrNextPckAck
#define TrPckAck                		op_sv_ptr->TrPckAck
#define cwnd                    		op_sv_ptr->cwnd
#define cwnd_start_seq          		op_sv_ptr->cwnd_start_seq
#define ack_seq_cnt             		op_sv_ptr->ack_seq_cnt
#define HandlesList             		op_sv_ptr->HandlesList
#define RecNextAckNum           		op_sv_ptr->RecNextAckNum
#define MSS                     		op_sv_ptr->MSS
#define pkts_in_flight          		op_sv_ptr->pkts_in_flight
#define cwnd_thr                		op_sv_ptr->cwnd_thr
#define cong_flag               		op_sv_ptr->cong_flag
#define SRTT                    		op_sv_ptr->SRTT
#define RTT                     		op_sv_ptr->RTT
#define SDEV                    		op_sv_ptr->SDEV
#define RTTList                 		op_sv_ptr->RTTList
#define Retr_Cnt_Ack            		op_sv_ptr->Retr_Cnt_Ack
#define fast_retr_flag          		op_sv_ptr->fast_retr_flag

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	pm_utp_process_old_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((pm_utp_process_old_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

void send_pkt_utp() 
	{
	Evhandle *hndl_ptr;
	double *double_ptr;
	//Packet* app_packet_ptr;
	Packet* tcp_packet_ptr;
	Packet* pkptr_queue;
	int pkt_size;
	double creation_time;
	FIN(send_pkt_utp());
	//printf("\n NODE %d IN SEND_PKT QSIZE=%f, cwnd=%d, cong_flag=%d, pkts_in_flight=%d, TrNextPckSeq=%d, cwnd_start_seq=%d", op_id_self (),QSize,cwnd,cong_flag,pkts_in_flight,TrNextPckSeq,cwnd_start_seq);
	if(QSize>0)
		{
		pkptr_queue = op_subq_pk_access (0, OPC_LISTPOS_HEAD);
		pkt_size=op_pk_total_size_get(pkptr_queue)/8;
		if(TrWaitAckSeq==cwnd_start_seq)
			{
			TrWaitAckSeq=(TrWaitAckSeq+pkt_size);
			}
		
		
		while(pkts_in_flight!=QSize)
			{
			pkptr_queue = op_subq_pk_access (0, pkts_in_flight);
			tcp_packet_ptr=op_pk_copy(pkptr_queue);
			pkt_size=op_pk_total_size_get(tcp_packet_ptr)/8;
			if((TrNextPckSeq+pkt_size)<=(cwnd+cwnd_start_seq))
				{
				creation_time=op_pk_creation_time_get(pkptr_queue);
				op_pk_creation_time_set (tcp_packet_ptr,creation_time);
				TrPckSeq=TrNextPckSeq;
				TrPckAck=TrNextPckAck;
				TrNextPckSeq=TrNextPckSeq+pkt_size;
				op_pk_nfd_set (tcp_packet_ptr, "seq_num",TrPckSeq);
				op_pk_nfd_set (tcp_packet_ptr, "ack_num",TrPckAck);
				op_pk_nfd_set (tcp_packet_ptr, "ack",DATA_PKT);
				op_pk_send(tcp_packet_ptr, TransStream);
				pkts_in_flight++;
				//printf("\n NODE %d has sent DATA packet of size=%d, now pkts_in_flight=%d, TrNextPckSeq will be: %d", op_id_self (),pkt_size,pkts_in_flight,TrNextPckSeq);
				//printf("\n NODE %d now TrWaitAckSeq=%d,cwnd+cwnd_start_seq=%d, timestamp:%f", op_id_self (),TrWaitAckSeq,cwnd+cwnd_start_seq,op_sim_time());
				/*Run timer*/
				Timer = op_intrpt_schedule_self(op_sim_time() + TimeOutTimer, op_pk_id (tcp_packet_ptr));
				hndl_ptr = (Evhandle *)op_prg_mem_alloc(sizeof(Evhandle)); 
				*hndl_ptr = Timer;
				op_prg_list_insert(HandlesList, hndl_ptr, OPC_LISTPOS_TAIL);
				/*Add timeout estimation record to the list*/
				double_ptr = (double *)op_prg_mem_alloc(sizeof(double)); 
				*double_ptr = op_sim_time();
				op_prg_list_insert(RTTList, double_ptr, OPC_LISTPOS_TAIL);
				//printf("\n NODE %d RTT SMP taken - timestamp:%f! ",op_topo_parent(op_id_self()),*double_ptr);
				}
			else
				break;
			}
			
		
		}
	else 
		{
		//printf("\n NODE %d send_pkt() - empty queue, timestamp:%f! ",op_topo_parent(op_id_self()),op_sim_time());
		}
	FOUT; 
	}



void cancel_timers_utp()
	{
	Evhandle *hndl_ptr;
	FIN(cancel_timers_utp());
	while(op_prg_list_size (HandlesList)!=0)
		{
		hndl_ptr = (Evhandle *)op_prg_list_access(HandlesList, OPC_LISTPOS_HEAD);
		Timer=*hndl_ptr;
		op_ev_cancel_if_pending (Timer);
		op_prg_mem_free(op_prg_list_remove(HandlesList, OPC_LISTPOS_HEAD));
		}
	while(op_prg_list_size (RTTList)!=0)
		{
		op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
		}
	
	FOUT;
	}


void cong_contr_utp(int ack_num)
	{
	double g=0.125,h=0.25,f=8, SERR, granuality=0.1, RTOmin=1.0;
	Packet* tcp_packet_ptr;
	Packet* pkptr_queue;
	int pkt_size;
	FIN(cong_contr_utp(ack_num));
	
	
	if(cong_flag==SLOW_START)
		{
		cwnd=cwnd*2;
		if(cwnd>=cwnd_thr)
			{
			cwnd=cwnd_thr;
			cong_flag=CONG_AV;
			}
		}
	
	else if(cong_flag==CONG_AV )
		{
		if(QSize>0 && pkts_in_flight!=QSize)
			{
			pkptr_queue = op_subq_pk_access (0, pkts_in_flight);
			tcp_packet_ptr=op_pk_copy(pkptr_queue);
			pkt_size=op_pk_total_size_get(tcp_packet_ptr)/8;
			op_pk_destroy(tcp_packet_ptr);
			if((TrNextPckSeq+pkt_size)<=(cwnd+cwnd_start_seq))
				{
				cwnd=cwnd+MSS;
				}
			}
		}
	//printf("\n NODE %d Report, QSize=%f, cwnd_flag=%d, cwnd=%d,cwnd_thr=%d, timestamp:%f", op_id_self (),QSize,cong_flag,cwnd,cwnd_thr,op_sim_time ());
	/*Timer Estimation Function*/
	if(ack_num>=TrWaitAckSeq)
		{
		if(Retr_Cnt_Ack==0)
			{
			RTT=op_sim_time()-RTT;
			op_stat_write (rtt_stat_hndl,RTT);
			//printf("\n NODE %d RTT SMP:%f! ",op_topo_parent(op_id_self()),RTT);
			if(RTT>0.2 || RTT<0.08)
				op_prg_odb_bkpt("SMP_RTT_ERR");
			if(RTT>=SRTT)
				SERR = RTT - SRTT;
			else
				SERR = SRTT - RTT;
		
			SRTT=(1-g)*SRTT+g*RTT;
			SDEV=(1-h)*SDEV+h*SERR;
			if(f*SDEV>granuality)
				TimeOutTimer=SRTT+f*SDEV;
			else
				TimeOutTimer=SRTT+granuality;
			
			if(TimeOutTimer<RTOmin)
				TimeOutTimer=RTOmin;
			}
		//printf("\n NODE %d RTT TimeOutTimer:%f, SDEV:%f! ",op_topo_parent(op_id_self()),TimeOutTimer,SDEV);
		
		}
	FOUT;
	}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void pm_utp_process_old (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_pm_utp_process_old_init (int * init_block_ptr);
	void _op_pm_utp_process_old_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_pm_utp_process_old_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_pm_utp_process_old_alloc (VosT_Obtype, int);
	void _op_pm_utp_process_old_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
pm_utp_process_old (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (pm_utp_process_old ());

		{
		/* Temporary Variables */
		int pkt_type=DATA_PKT;
		int seq,ack_num;
		Packet* packet_ptr;
		/* End of Temporary Variables */


		FSM_ENTER ("pm_utp_process_old")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "INIT", "pm_utp_process_old [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process_old [INIT enter execs]", state0_enter_exec)
				{
				/*ID of the connections Incoming*/
				Objid MyID, StrmID, OtherID;
				int index, InStreams,OutStreams;
				char ModuleName[64];
				MyID = op_id_self();
				
				cong_flag=SLOW_START;
				
				rtt_stat_hndl   = op_stat_reg ("uTP.RTT",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				retr_hndl   = op_stat_reg ("uTP.Retransmissions",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				InStreams = op_topo_assoc_count(MyID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STRM);
				OutStreams = op_topo_assoc_count(MyID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_STRM);
				/*Find the Packet and AppData Streams*/
				
				for (index = 0; index < InStreams; index++)
				{
					/*Find the stream index at the specific association*/
					StrmID = op_topo_assoc(MyID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STRM, index);
					
					if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PROC)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PROC,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "Application") == 0)
							{
								op_ima_obj_attr_get(StrmID, "dest stream", &AppDataStream);
							}
					}
					if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PTRX)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PTRX,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "RX") == 0)
							{
								op_ima_obj_attr_get(StrmID, "dest stream", &PckStream);
							}
					}
				}
				
				for (index = 0; index < OutStreams; index++)
				{
					/*Find the stream index at the specific association*/
					StrmID = op_topo_assoc(MyID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_STRM, index);
					
					if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PROC)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PROC,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "Application") == 0)
							{
								op_ima_obj_attr_get(StrmID, "src stream", &SinkStream);
								printf("SinkStream: %d\n",SinkStream);
							}
					}
					else if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PTTX)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PTTX,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "TX") == 0)
							{
								op_ima_obj_attr_get(StrmID, "src stream", &TransStream);
								printf("TransStream: %d\n",TransStream);
							}
					}
				}
				
				/*Initialization*/
				SRTT=1.0;
				SRTT=0;
				SDEV=0;
				TimeOutTimer=1.0;
				fast_retr_flag=0;
				MSS=1400; //byte
				RecNextPckSeq=0;
				TrNextPckSeq=0;
				TrNextPckAck=0;
				retr_per_pkt=0;
				retr=0;
				cwnd=1*MSS;
				cwnd_thr=10*MSS;
				cwnd_start_seq=0;
				ack_seq_cnt=0;
				pkts_in_flight=0;
				RTTList= op_prg_list_create();
				HandlesList = op_prg_list_create();
				op_prg_list_init(RTTList);
				op_prg_list_init(HandlesList);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "INIT", "pm_utp_process_old [INIT exit execs]")


			/** state (INIT) transition processing **/
			FSM_TRANSIT_ONLY ((PowerUp), 1, state1_enter_exec, ;, INIT, "PowerUp", "", "INIT", "ESTAB", "tr_10", "pm_utp_process_old [INIT -> ESTAB : PowerUp / ]")
				/*---------------------------------------------------------*/



			/** state (ESTAB) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "ESTAB", state1_enter_exec, "pm_utp_process_old [ESTAB enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"pm_utp_process_old")


			/** state (ESTAB) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "ESTAB", "pm_utp_process_old [ESTAB exit execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process_old [ESTAB exit execs]", state1_exit_exec)
				{
				if(PacketArrival)
					{
					packet_ptr = op_pk_get(op_intrpt_strm());
					//printf("\n NODE %d PCKT ARRIVAL, size=%d", op_id_self (),op_pk_total_size_get(packet_ptr));
					op_pk_nfd_get (packet_ptr, "ack",&pkt_type);
					}
				else if(AppDataArrival)
					{
					packet_ptr = op_pk_get(op_intrpt_strm());
					//printf("\n NODE %d APPDATA ARRIVAL, size=%d, timestamp:%f", op_id_self (),op_pk_total_size_get(packet_ptr)/8,op_sim_time());
					}
				else  if(TimerOver)
					{
					//printf("\n NODE %d TimerOver, timestamp:%f", op_id_self (),op_sim_time () );
					}
				else 
					{
					//printf("\n NODE %d WTF", op_id_self ());
					}
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (ESTAB) transition processing **/
			FSM_PROFILE_SECTION_IN ("pm_utp_process_old [ESTAB trans conditions]", state1_trans_conds)
			FSM_INIT_COND (AppDataArrival)
			FSM_TEST_COND (AckPacketArrival)
			FSM_TEST_COND (DataPacketArrival)
			FSM_TEST_COND (TimerOver)
			FSM_TEST_LOGIC ("ESTAB")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "AppDataArrival", "", "ESTAB", "AppData_HNDL", "tr_12", "pm_utp_process_old [ESTAB -> AppData_HNDL : AppDataArrival / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "AckPacketArrival", "", "ESTAB", "Ack_HNDL", "tr_16", "pm_utp_process_old [ESTAB -> Ack_HNDL : AckPacketArrival / ]")
				FSM_CASE_TRANSIT (2, 5, state5_enter_exec, ;, "DataPacketArrival", "", "ESTAB", "Pkt_hndl", "tr_23", "pm_utp_process_old [ESTAB -> Pkt_hndl : DataPacketArrival / ]")
				FSM_CASE_TRANSIT (3, 4, state4_enter_exec, ;, "TimerOver", "", "ESTAB", "Retr_hndl", "tr_27", "pm_utp_process_old [ESTAB -> Retr_hndl : TimerOver / ]")
				}
				/*---------------------------------------------------------*/



			/** state (AppData_HNDL) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "AppData_HNDL", state2_enter_exec, "pm_utp_process_old [AppData_HNDL enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process_old [AppData_HNDL enter execs]", state2_enter_exec)
				{
				Packet* tcp_packet_ptr;
				tcp_packet_ptr = op_pk_create_fmt ("pm_tcp_packet");
				op_pk_nfd_set_pkt (tcp_packet_ptr, "data_field", packet_ptr);
				/*Copy pkt and queue it*/
				if(op_subq_pk_insert(0, tcp_packet_ptr, OPC_QPOS_TAIL)!= OPC_QINS_OK)
					printf("\n Packet not queued");
					
					
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (AppData_HNDL) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "AppData_HNDL", "pm_utp_process_old [AppData_HNDL exit execs]")


			/** state (AppData_HNDL) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, send_pkt_utp();, "default", "send_pkt_utp()", "AppData_HNDL", "ESTAB", "tr_18", "pm_utp_process_old [AppData_HNDL -> ESTAB : default / send_pkt_utp()]")
				/*---------------------------------------------------------*/



			/** state (Ack_HNDL) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "Ack_HNDL", state3_enter_exec, "pm_utp_process_old [Ack_HNDL enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process_old [Ack_HNDL enter execs]", state3_enter_exec)
				{
				Packet* queue_packet_ptr;
				Evhandle *hndl_ptr;
				double *double_ptr;
				int i,n,pkt_size;
				op_pk_nfd_access (packet_ptr, "seq_num", &seq);
				op_pk_nfd_access (packet_ptr, "ack_num", &ack_num);
				/*ACK is proper*/
				//printf("\n NODE %d has received ACK packet, ack=%d, ExpecAck=%d, timestamp:%f", op_id_self (),ack_num,TrWaitAckSeq,op_sim_time());
				if(ack_num==TrWaitAckSeq)
					{
					/****Congestion window deflation for fast retransmit****/
					if(fast_retr_flag==1)
						{
						cwnd=cwnd_thr;
						fast_retr_flag=0;
						}
					/*Upade the statistics*/
					op_stat_write (retr_hndl,retr=retr+retr_per_pkt);
					retr_per_pkt=0;
								
					/*Removing copy of the acknowledged packet from the proper queue and destroying*/
					queue_packet_ptr = op_subq_pk_remove (0, OPC_QPOS_HEAD);
					op_pk_destroy (queue_packet_ptr);
					hndl_ptr = (Evhandle *)op_prg_list_access(HandlesList, OPC_LISTPOS_HEAD);
					Timer=*hndl_ptr;
					op_ev_cancel(Timer);
					op_prg_mem_free(op_prg_list_remove(HandlesList, OPC_LISTPOS_HEAD));
					/*Update sliding window, parameters and doubled acks stat*/
					cwnd_start_seq=TrWaitAckSeq;
					
					if(pkts_in_flight!=0)
						{
						pkts_in_flight--;
						}
					
					/*Update Sample RTT value*****************************************/
					if(op_prg_list_size (RTTList)!=0)
							{
							double_ptr = (double *)op_prg_list_access(RTTList, OPC_LISTPOS_HEAD);
							RTT=*double_ptr;
							//printf("\n NODE %d received ack, cwnd_start_seq=%d, RTT=%f", op_id_self (),cwnd_start_seq,RTT);
							op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
							}
					/*****************************************************************/
					ack_seq_cnt=0;
					TrNextPckAck=seq;
					op_pk_destroy(packet_ptr);
					cong_contr_utp(ack_num);
					
					if(Retr_Cnt_Ack!=0)
						{
						Retr_Cnt_Ack=Retr_Cnt_Ack-1.0;
						}
					}
					/*ACK is not proper*/
				else if(ack_num>TrWaitAckSeq)
					{
					op_prg_odb_bkpt("CACK");
					
					/****Congestion window deflation for fast retransmit****/
					if(fast_retr_flag==1)
						{
						cwnd=cwnd_thr;
						fast_retr_flag=0;
						}
					/*Upade the statistics*/
					op_stat_write (retr_hndl,retr=retr+retr_per_pkt);
					retr_per_pkt=0;			
					/*Removing copy of the acknowledged packet from the proper queue and destroying*/
					i=TrWaitAckSeq;
					while(i<=ack_num)
						{
						queue_packet_ptr = op_subq_pk_remove (0, OPC_QPOS_HEAD);
						pkt_size=op_pk_total_size_get(queue_packet_ptr)/8;
						//printf("\n NODE %d pkt size=%d", op_id_self (),pkt_size);
						hndl_ptr = (Evhandle *)op_prg_list_access(HandlesList, OPC_LISTPOS_HEAD);
						Timer=*hndl_ptr;
						op_ev_cancel(Timer);
						op_prg_mem_free(op_prg_list_remove(HandlesList, OPC_LISTPOS_HEAD));
						op_pk_destroy (queue_packet_ptr);
						//printf("\n NODE %d remove and destroy packet from the queue, i=%d", op_id_self (),i);
						if(pkts_in_flight!=0)
							{
							pkts_in_flight--;
							}
						if(Retr_Cnt_Ack!=0)
							{
							Retr_Cnt_Ack=Retr_Cnt_Ack-1.0;
							}
						
						i=i+pkt_size;
						/*Update Sample RTT value*****************************************/
						if(op_prg_list_size (RTTList)!=0)
							{
							if(i==ack_num)
								{
								double_ptr = (double *)op_prg_list_access(RTTList, OPC_LISTPOS_HEAD);
								RTT=*double_ptr;
								//printf("\n NODE %d CUMMULATIVE ACK, RTT=%f", op_id_self (),RTT);
								}
							op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
						/*****************************************************************/
							}
						}
					/*Update sliding window, parameters and doubled acks stat*/
					cwnd_start_seq=ack_num;
					TrWaitAckSeq=ack_num;
					ack_seq_cnt=0;
					op_pk_nfd_access (packet_ptr, "ack_num", &TrNextPckSeq);
					TrNextPckAck=seq;
					//printf("\n NODE %d destroy ack", op_id_self ());
					op_pk_destroy(packet_ptr);
					cong_contr_utp(ack_num);
					}
				else if(ack_num<TrWaitAckSeq)
					{
					op_prg_odb_bkpt("WRACK");
					/****Congestion window inflation for fast retransmit****/
					if(fast_retr_flag==1)
						cwnd=cwnd+MSS;
					
					ack_seq_cnt++;
					op_pk_destroy(packet_ptr);
					/*Update Sample RTT value*/
					i=ack_num;
					n=0;
					if(Retr_Cnt_Ack==0)
						{
						while(i==TrWaitAckSeq)
							{
							queue_packet_ptr = op_subq_pk_access (0, n);
							pkt_size=op_pk_total_size_get(queue_packet_ptr)/8;
							n++;
							i=i+pkt_size;
							}
						i=n;
						while(i==0)
							{
							if(i<=op_prg_list_size (RTTList))
								{
								if(op_prg_list_size (RTTList)!=0)
									{
									double_ptr = (double *)op_prg_list_access(RTTList, i);
									//printf("\n NODE %d DUPLICATE ACK, RTT=%f", op_id_self (),*double_ptr);
									op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
									}
								}
							i--;
							}
						}
					/********/
					}
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (Ack_HNDL) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "Ack_HNDL", "pm_utp_process_old [Ack_HNDL exit execs]")


			/** state (Ack_HNDL) transition processing **/
			FSM_PROFILE_SECTION_IN ("pm_utp_process_old [Ack_HNDL trans conditions]", state3_trans_conds)
			FSM_INIT_COND (FastRetrans)
			FSM_TEST_COND (ack_num>=TrWaitAckSeq && ack_seq_cnt<4)
			FSM_TEST_COND (ack_num<TrWaitAckSeq  && ack_seq_cnt<4)
			FSM_TEST_LOGIC ("Ack_HNDL")
			FSM_PROFILE_SECTION_OUT (state3_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 4, state4_enter_exec, ;, "FastRetrans", "", "Ack_HNDL", "Retr_hndl", "tr_19", "pm_utp_process_old [Ack_HNDL -> Retr_hndl : FastRetrans / ]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, send_pkt_utp();, "ack_num>=TrWaitAckSeq && ack_seq_cnt<4", "send_pkt_utp()", "Ack_HNDL", "ESTAB", "tr_21", "pm_utp_process_old [Ack_HNDL -> ESTAB : ack_num>=TrWaitAckSeq && ack_seq_cnt<4 / send_pkt_utp()]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "ack_num<TrWaitAckSeq  && ack_seq_cnt<4", "", "Ack_HNDL", "ESTAB", "tr_22", "pm_utp_process_old [Ack_HNDL -> ESTAB : ack_num<TrWaitAckSeq  && ack_seq_cnt<4 / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Retr_hndl) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "Retr_hndl", state4_enter_exec, "pm_utp_process_old [Retr_hndl enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process_old [Retr_hndl enter execs]", state4_enter_exec)
				{
				if(TimerOver)
					{
					//printf("\n NODE %d TimerOver, Retr_Cnt_Ack=%f, cwnd_flag=%d, cwnd=%d, pkts_in_flight=%d, TrNextPckSeq=%d, cwnd_start_seq=%d, timestamp:%f", op_id_self (),QSize,cong_flag,cwnd, pkts_in_flight, TrNextPckSeq, cwnd_start_seq,op_sim_time () );
					Retr_Cnt_Ack=QSize;
					TimeOutTimer=TimeOutTimer*2;
					op_prg_odb_bkpt("RETR");
					ack_seq_cnt=0;
					cancel_timers_utp();
					pkts_in_flight=0;
					retr_per_pkt++;
					TrNextPckSeq=cwnd_start_seq;
					if(cwnd/2>=MSS)
						{
						cwnd_thr=cwnd/2;
						cwnd=MSS;
						cong_flag=SLOW_START;
						}
					else
						{
						cwnd_thr=MSS;
						cwnd=MSS;
						cong_flag=CONG_AV;
						}
					}
				else if (FastRetrans)
					{
					//printf("\n NODE %d FastRetrans, Retr_Cnt_Ack=%f, cwnd_flag=%d, cwnd=%d, pkts_in_flight=%d, TrNextPckSeq=%d, cwnd_start_seq=%d, timestamp:%f", op_id_self (),QSize,cong_flag,cwnd, pkts_in_flight, TrNextPckSeq, cwnd_start_seq,op_sim_time () );
					Retr_Cnt_Ack=QSize;
					fast_retr_flag=1;
					TimeOutTimer=TimeOutTimer*2;
					op_prg_odb_bkpt("RETR");
					cancel_timers_utp();
					ack_seq_cnt=0;
					pkts_in_flight=0;
					retr_per_pkt++;
					TrNextPckSeq=ack_num;
					if(cwnd/2>=2*MSS)
						{
						cwnd_thr=cwnd/2;
						}
					else
						{
						cwnd_thr=2*MSS;
						}
					cwnd=cwnd_thr+3*MSS;
					cong_flag=CONG_AV;
					}
				//printf("\n NODE %d Report, cwnd_flag=%d, cwnd=%d,cwnd_thr=%d, timestamp:%f", op_id_self (),cong_flag,cwnd,cwnd_thr,op_sim_time ());
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (Retr_hndl) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "Retr_hndl", "pm_utp_process_old [Retr_hndl exit execs]")


			/** state (Retr_hndl) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, send_pkt_utp();, "default", "send_pkt_utp()", "Retr_hndl", "ESTAB", "tr_20", "pm_utp_process_old [Retr_hndl -> ESTAB : default / send_pkt_utp()]")
				/*---------------------------------------------------------*/



			/** state (Pkt_hndl) enter executives **/
			FSM_STATE_ENTER_FORCED (5, "Pkt_hndl", state5_enter_exec, "pm_utp_process_old [Pkt_hndl enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process_old [Pkt_hndl enter execs]", state5_enter_exec)
				{
				/*Data packet arrival*/
				Packet* app_packet_ptr;
				Packet* ackptr;
				int ack_nt_ack_num, ack_nt_seq_num,pkt_size;
				double cr_time;
				op_pk_nfd_access(packet_ptr, "seq_num", &seq);
				op_pk_nfd_access(packet_ptr, "ack_num", &ack_nt_seq_num);
				//printf("\n NODE %d DataPktArr of seq=%d, Exp seq=%d", op_topo_parent(op_id_self()),seq,RecNextPckSeq);
				if(seq==RecNextPckSeq)
					{
					op_pk_nfd_get_pkt (packet_ptr, "data_field", &app_packet_ptr);
					pkt_size=op_pk_total_size_get(app_packet_ptr)/8;
					cr_time=op_pk_creation_time_get (app_packet_ptr);
					op_pk_send(app_packet_ptr, SinkStream);
					RecNextPckSeq=RecNextPckSeq+pkt_size;
					op_pk_destroy (packet_ptr);
					//printf("\n NODE %d Destroying packet", op_topo_parent(op_id_self()));
					
					ack_nt_ack_num=RecNextPckSeq;		
					ackptr = op_pk_create_fmt ("pm_tcp_packet");
					op_pk_nfd_set (ackptr, "seq_num", ack_nt_seq_num);
					op_pk_nfd_set (ackptr, "ack_num", ack_nt_ack_num);
					op_pk_nfd_set (ackptr, "ack", ACK);
					op_pk_send(ackptr, TransStream);
					//printf("\n NODE %d DataPktArr of size=%d, ack_num=%d,timestamp: %f, creation:%f", op_topo_parent(op_id_self()),pkt_size,ack_nt_ack_num,op_sim_time(),cr_time);
					}
				else if(seq<RecNextPckSeq)
					{
					op_pk_destroy (packet_ptr);
					//printf("\n NODE %d Destroying packet", op_topo_parent(op_id_self()));
					}
				else
					{
					op_pk_destroy (packet_ptr);
					//printf("\n NODE %d Destroying packet", op_topo_parent(op_id_self()));
					ack_nt_ack_num=RecNextPckSeq;		
					ackptr = op_pk_create_fmt ("pm_tcp_packet");
					op_pk_nfd_set (ackptr, "seq_num", ack_nt_seq_num);
					op_pk_nfd_set (ackptr, "ack_num", ack_nt_ack_num);
					op_pk_nfd_set (ackptr, "ack", ACK);
					op_pk_send(ackptr, TransStream);
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** state (Pkt_hndl) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "Pkt_hndl", "pm_utp_process_old [Pkt_hndl exit execs]")


			/** state (Pkt_hndl) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Pkt_hndl", "ESTAB", "tr_24", "pm_utp_process_old [Pkt_hndl -> ESTAB : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"pm_utp_process_old")
		}
	}




void
_op_pm_utp_process_old_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_pm_utp_process_old_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_pm_utp_process_old_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_pm_utp_process_old_svar function. */
#undef PckStream
#undef AppDataStream
#undef SinkStream
#undef TransStream
#undef RecNextPckSeq
#undef TrNextPckSeq
#undef TrWaitAckSeq
#undef rtt_stat_hndl
#undef retr_per_pkt
#undef TimeOutTimer
#undef Timer
#undef DataPktArr
#undef TrPckSeq
#undef retr_hndl
#undef retr
#undef new_variable
#undef TrNextPckAck
#undef TrPckAck
#undef cwnd
#undef cwnd_start_seq
#undef ack_seq_cnt
#undef HandlesList
#undef RecNextAckNum
#undef MSS
#undef pkts_in_flight
#undef cwnd_thr
#undef cong_flag
#undef SRTT
#undef RTT
#undef SDEV
#undef RTTList
#undef Retr_Cnt_Ack
#undef fast_retr_flag

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_pm_utp_process_old_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_pm_utp_process_old_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (pm_utp_process_old)",
		sizeof (pm_utp_process_old_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_pm_utp_process_old_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	pm_utp_process_old_state * ptr;
	FIN_MT (_op_pm_utp_process_old_alloc (obtype))

	ptr = (pm_utp_process_old_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "pm_utp_process_old [INIT enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_pm_utp_process_old_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	pm_utp_process_old_state		*prs_ptr;

	FIN_MT (_op_pm_utp_process_old_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (pm_utp_process_old_state *)gen_ptr;

	if (strcmp ("PckStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->PckStream);
		FOUT
		}
	if (strcmp ("AppDataStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->AppDataStream);
		FOUT
		}
	if (strcmp ("SinkStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SinkStream);
		FOUT
		}
	if (strcmp ("TransStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TransStream);
		FOUT
		}
	if (strcmp ("RecNextPckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RecNextPckSeq);
		FOUT
		}
	if (strcmp ("TrNextPckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrNextPckSeq);
		FOUT
		}
	if (strcmp ("TrWaitAckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrWaitAckSeq);
		FOUT
		}
	if (strcmp ("rtt_stat_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rtt_stat_hndl);
		FOUT
		}
	if (strcmp ("retr_per_pkt" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retr_per_pkt);
		FOUT
		}
	if (strcmp ("TimeOutTimer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TimeOutTimer);
		FOUT
		}
	if (strcmp ("Timer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Timer);
		FOUT
		}
	if (strcmp ("DataPktArr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DataPktArr);
		FOUT
		}
	if (strcmp ("TrPckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrPckSeq);
		FOUT
		}
	if (strcmp ("retr_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retr_hndl);
		FOUT
		}
	if (strcmp ("retr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retr);
		FOUT
		}
	if (strcmp ("new_variable" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->new_variable);
		FOUT
		}
	if (strcmp ("TrNextPckAck" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrNextPckAck);
		FOUT
		}
	if (strcmp ("TrPckAck" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrPckAck);
		FOUT
		}
	if (strcmp ("cwnd" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd);
		FOUT
		}
	if (strcmp ("cwnd_start_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd_start_seq);
		FOUT
		}
	if (strcmp ("ack_seq_cnt" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_seq_cnt);
		FOUT
		}
	if (strcmp ("HandlesList" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->HandlesList);
		FOUT
		}
	if (strcmp ("RecNextAckNum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RecNextAckNum);
		FOUT
		}
	if (strcmp ("MSS" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->MSS);
		FOUT
		}
	if (strcmp ("pkts_in_flight" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_in_flight);
		FOUT
		}
	if (strcmp ("cwnd_thr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd_thr);
		FOUT
		}
	if (strcmp ("cong_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cong_flag);
		FOUT
		}
	if (strcmp ("SRTT" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SRTT);
		FOUT
		}
	if (strcmp ("RTT" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RTT);
		FOUT
		}
	if (strcmp ("SDEV" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SDEV);
		FOUT
		}
	if (strcmp ("RTTList" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RTTList);
		FOUT
		}
	if (strcmp ("Retr_Cnt_Ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Retr_Cnt_Ack);
		FOUT
		}
	if (strcmp ("fast_retr_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fast_retr_flag);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

