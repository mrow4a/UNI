/* Process model C form file: pm_utp_process.pr.c */
/* Portions of this file copyright 1986-2012 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from pm_utp_process.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char pm_utp_process_pr_c [] = "MIL_3_Tfile_Hdr_ 171A 30A modeler 7 5567EA9B 5567EA9B 1 FTNK-B0013 s146147 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 2b74 2                                                                                                                                                                                                                                                                                                                                                                                                       ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#define PowerUp (op_intrpt_type() == OPC_INTRPT_BEGSIM) 
#define PacketArrival (op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm()==PckStream) 
#define AppDataArrival (op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm()==AppDataStream)
#define TimerOver (op_intrpt_type() == OPC_INTRPT_SELF) 
#define DataPacketArrival (PacketArrival && pkt_type==DATA_PKT)
#define AckPacketArrival (PacketArrival && (pkt_type==ACK || pkt_type==DUP_PKT_ACK))
#define FastRetrans (ack_num<TrWaitAckSeq  && ack_seq_cnt>=4)
/* Macro for determining the number of packets in the queue */ 
#define QSize (op_subq_stat(0, OPC_QSTAT_PKSIZE))
#define DUP_PKT_ACK 2
#define ACK 1
#define DATA_PKT 0
#define DEST_PORT_TCP_APP 0
#define AppDestroyed (app_data_flag==0)
#define SLOW_START 0
#define CONG_AV 1
#define UTP_ON (utp_on_hndl==1)

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	int	                    		PckStream                                       ;
	int	                    		AppDataStream                                   ;
	int	                    		SinkStream                                      ;
	int	                    		TransStream                                     ;
	int	                    		RecNextPckSeq                                   ;
	int	                    		TrNextPckSeq                                    ;
	int	                    		TrWaitAckSeq                                    ;
	Stathandle	             		rtt_stat_hndl                                   ;
	double	                 		retr_per_pkt                                    ;
	double	                 		TimeOutTimer                                    ;
	Evhandle	               		Timer                                           ;
	Boolean	                		DataPktArr                                      ;
	int	                    		TrPckSeq                                        ;
	Stathandle	             		retr_hndl                                       ;
	double	                 		retr                                            ;
	int	                    		TrNextPckAck                                    ;
	int	                    		TrPckAck                                        ;
	int	                    		cwnd                                            ;
	int	                    		cwnd_start_seq                                  ;
	int	                    		ack_seq_cnt                                     ;
	List*	                  		HandlesList                                     ;
	int	                    		RecNextAckNum                                   ;
	int	                    		MSS                                             ;
	int	                    		pkts_in_flight                                  ;
	int	                    		cwnd_thr                                        ;
	int	                    		cong_flag                                       ;
	double	                 		SRTT                                            ;
	double	                 		RTT                                             ;
	double	                 		SDEV                                            ;
	List*	                  		RTTList                                         ;
	double	                 		Retr_Cnt_Ack                                    ;
	int	                    		fast_retr_flag                                  ;
	int	                    		next_pkt_type                                   ;
	int	                    		ack_num                                         ;
	int	                    		seq                                             ;
	double	                 		timestamp                                       ;
	Stathandle	             		one_way_delay_hndl                              ;
	int	                    		cwnd_thr_min                                    ;
	double	                 		timestamp_difference                            ;
	int	                    		FILTER_TYPE                                     ;
	double	                 		TARGET                                          ;
	double	                 		GAIN                                            ;
	double	                 		base_delay                                      ;
	List*	                  		BaseDelayList                                   ;
	List*	                  		CurrentDelayList                                ;
	int	                    		utp_on_hndl                                     ;
	double	                 		last_rollover                                   ;
	double	                 		init_base_delay                                 ;
	double	                 		est_timestamp_difference                        ;
	double	                 		GAIN_NEG_ON                                     ;
	} pm_utp_process_state;

#define PckStream               		op_sv_ptr->PckStream
#define AppDataStream           		op_sv_ptr->AppDataStream
#define SinkStream              		op_sv_ptr->SinkStream
#define TransStream             		op_sv_ptr->TransStream
#define RecNextPckSeq           		op_sv_ptr->RecNextPckSeq
#define TrNextPckSeq            		op_sv_ptr->TrNextPckSeq
#define TrWaitAckSeq            		op_sv_ptr->TrWaitAckSeq
#define rtt_stat_hndl           		op_sv_ptr->rtt_stat_hndl
#define retr_per_pkt            		op_sv_ptr->retr_per_pkt
#define TimeOutTimer            		op_sv_ptr->TimeOutTimer
#define Timer                   		op_sv_ptr->Timer
#define DataPktArr              		op_sv_ptr->DataPktArr
#define TrPckSeq                		op_sv_ptr->TrPckSeq
#define retr_hndl               		op_sv_ptr->retr_hndl
#define retr                    		op_sv_ptr->retr
#define TrNextPckAck            		op_sv_ptr->TrNextPckAck
#define TrPckAck                		op_sv_ptr->TrPckAck
#define cwnd                    		op_sv_ptr->cwnd
#define cwnd_start_seq          		op_sv_ptr->cwnd_start_seq
#define ack_seq_cnt             		op_sv_ptr->ack_seq_cnt
#define HandlesList             		op_sv_ptr->HandlesList
#define RecNextAckNum           		op_sv_ptr->RecNextAckNum
#define MSS                     		op_sv_ptr->MSS
#define pkts_in_flight          		op_sv_ptr->pkts_in_flight
#define cwnd_thr                		op_sv_ptr->cwnd_thr
#define cong_flag               		op_sv_ptr->cong_flag
#define SRTT                    		op_sv_ptr->SRTT
#define RTT                     		op_sv_ptr->RTT
#define SDEV                    		op_sv_ptr->SDEV
#define RTTList                 		op_sv_ptr->RTTList
#define Retr_Cnt_Ack            		op_sv_ptr->Retr_Cnt_Ack
#define fast_retr_flag          		op_sv_ptr->fast_retr_flag
#define next_pkt_type           		op_sv_ptr->next_pkt_type
#define ack_num                 		op_sv_ptr->ack_num
#define seq                     		op_sv_ptr->seq
#define timestamp               		op_sv_ptr->timestamp
#define one_way_delay_hndl      		op_sv_ptr->one_way_delay_hndl
#define cwnd_thr_min            		op_sv_ptr->cwnd_thr_min
#define timestamp_difference    		op_sv_ptr->timestamp_difference
#define FILTER_TYPE             		op_sv_ptr->FILTER_TYPE
#define TARGET                  		op_sv_ptr->TARGET
#define GAIN                    		op_sv_ptr->GAIN
#define base_delay              		op_sv_ptr->base_delay
#define BaseDelayList           		op_sv_ptr->BaseDelayList
#define CurrentDelayList        		op_sv_ptr->CurrentDelayList
#define utp_on_hndl             		op_sv_ptr->utp_on_hndl
#define last_rollover           		op_sv_ptr->last_rollover
#define init_base_delay         		op_sv_ptr->init_base_delay
#define est_timestamp_difference		op_sv_ptr->est_timestamp_difference
#define GAIN_NEG_ON             		op_sv_ptr->GAIN_NEG_ON

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	pm_utp_process_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((pm_utp_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

void send_pkt_utp() 
	{
	Evhandle *hndl_ptr;
	double *double_ptr;
	//Packet* app_packet_ptr;
	Packet* tcp_packet_ptr;
	Packet* pkptr_queue;
	int pkt_size;
	double creation_time,timestamp_difference_send;
	FIN(send_pkt_utp());
	/*one-way-delay measurement */
	/****************/
	//printf("\n NODE %d IN SEND_PKT:next_pkt_type=%d, QSIZE=%f, cwnd=%d, cong_flag=%d, pkts_in_flight=%d, TrNextPckSeq=%d,TrNextPckAck=%d, cwnd_start_seq=%d", op_topo_parent(op_id_self()),next_pkt_type,QSize,cwnd,cong_flag,pkts_in_flight,TrNextPckSeq,TrNextPckAck,cwnd_start_seq);
	if(TrNextPckSeq<cwnd_start_seq)
		{
		//printf("\n NODE %d WTF??? timestamp:%f! ",op_topo_parent(op_id_self()),op_sim_time());
		op_prg_odb_bkpt("LOG_ERR");
		}
	
	if(QSize>0)
		{
		pkptr_queue = op_subq_pk_access (0, OPC_LISTPOS_HEAD);
		pkt_size=op_pk_total_size_get(pkptr_queue)/8;
		//printf("\n NODE %d IN SEND_PKT QSIZE=%f, cwnd=%d, cong_flag=%d, pkts_in_flight=%d, TrNextPckSeq=%d,TrNextPckAck=%d, cwnd_start_seq=%d,TrWaitAckSeq=%d", op_topo_parent(op_id_self()),QSize,cwnd,cong_flag,pkts_in_flight,TrNextPckSeq,TrNextPckAck,cwnd_start_seq,TrWaitAckSeq);
		if(TrWaitAckSeq==cwnd_start_seq)
			{
			TrWaitAckSeq=(TrWaitAckSeq+pkt_size);
			}
		
		if(pkts_in_flight==QSize && (next_pkt_type==ACK || next_pkt_type==DUP_PKT_ACK))
			{
			tcp_packet_ptr = op_pk_create_fmt ("pm_utp_packet");
			op_pk_nfd_set (tcp_packet_ptr, "seq_num",TrNextPckSeq);
			op_pk_nfd_set (tcp_packet_ptr, "ack_num",TrNextPckAck);
			op_pk_nfd_set (tcp_packet_ptr, "ack",next_pkt_type);
			op_pk_nfd_set (tcp_packet_ptr, "timestamp",op_sim_time());
			timestamp_difference_send=op_sim_time()-timestamp;
			op_pk_nfd_set (tcp_packet_ptr, "timestamp_difference",timestamp_difference_send);
			//printf("\n NODE %d has sent ACK seq=%d, ack=%d, packet id=%d",op_topo_parent(op_id_self()),TrNextPckSeq, TrNextPckAck,op_pk_id(tcp_packet_ptr));
			op_pk_send(tcp_packet_ptr, TransStream);
			next_pkt_type=DATA_PKT;
			}
		else if(pkts_in_flight!=QSize) 
			{
			pkptr_queue = op_subq_pk_access (0, pkts_in_flight);
			pkt_size=op_pk_total_size_get(pkptr_queue)/8;
			if(((TrNextPckSeq+pkt_size)>(cwnd+cwnd_start_seq)) && (next_pkt_type==ACK || next_pkt_type==DUP_PKT_ACK))
				{
				tcp_packet_ptr = op_pk_create_fmt ("pm_utp_packet");
				op_pk_nfd_set (tcp_packet_ptr, "seq_num",TrNextPckSeq);
				op_pk_nfd_set (tcp_packet_ptr, "ack_num",TrNextPckAck);
				op_pk_nfd_set (tcp_packet_ptr, "ack",next_pkt_type);
				op_pk_nfd_set (tcp_packet_ptr, "timestamp",op_sim_time());
				timestamp_difference_send=op_sim_time()-timestamp;
				op_pk_nfd_set (tcp_packet_ptr, "timestamp_difference",timestamp_difference_send);
				//printf("\n NODE %d has sent ACK seq=%d, ack=%d, packet id=%d",op_topo_parent(op_id_self()),TrNextPckSeq, TrNextPckAck,op_pk_id(tcp_packet_ptr));
				op_pk_send(tcp_packet_ptr, TransStream);
				next_pkt_type=DATA_PKT;
				}
			}
		
		while(pkts_in_flight!=QSize)
			{
			pkptr_queue = op_subq_pk_access (0, pkts_in_flight);
			tcp_packet_ptr=op_pk_copy(pkptr_queue);
			pkt_size=op_pk_total_size_get(tcp_packet_ptr)/8;
			//printf("\n NODE %d trying to send TrNextPckSeq+pkt_size=%d, cwnd+cwnd_start_seq=%d, timestamp:%f", op_topo_parent(op_id_self()),TrNextPckSeq+pkt_size,cwnd+cwnd_start_seq,op_sim_time());
			if((TrNextPckSeq+pkt_size)<=(cwnd+cwnd_start_seq))
				{
				creation_time=op_pk_creation_time_get(pkptr_queue);
				op_pk_creation_time_set (tcp_packet_ptr,creation_time);
				TrPckSeq=TrNextPckSeq;
				TrPckAck=TrNextPckAck;
				TrNextPckSeq=TrNextPckSeq+pkt_size;
				op_pk_nfd_set (tcp_packet_ptr, "seq_num",TrPckSeq);
				op_pk_nfd_set (tcp_packet_ptr, "ack_num",TrPckAck);
				op_pk_nfd_set (tcp_packet_ptr, "ack",next_pkt_type);
				op_pk_nfd_set (tcp_packet_ptr, "timestamp",op_sim_time());
				
				//printf("\n NODE %d has sent packet of type=%d, seq=%d, ack=%d, size=%d,pkt_id=%d, now pkts_in_flight=%d, TrNextPckSeq will be: %d", op_topo_parent(op_id_self()),next_pkt_type, TrPckSeq, TrPckAck,pkt_size,op_pk_id(tcp_packet_ptr),pkts_in_flight,TrNextPckSeq);
				if(next_pkt_type==ACK || next_pkt_type==DUP_PKT_ACK)
					{
					next_pkt_type=DATA_PKT;
					timestamp_difference_send=op_sim_time()-timestamp;
					op_pk_nfd_set (tcp_packet_ptr, "timestamp_difference",timestamp_difference_send);
					}
				op_pk_send(tcp_packet_ptr, TransStream);
				pkts_in_flight++;
				
				
				/*Run timer*/
				Timer = op_intrpt_schedule_self(op_sim_time() + TimeOutTimer, op_pk_id (tcp_packet_ptr));
				hndl_ptr = (Evhandle *)op_prg_mem_alloc(sizeof(Evhandle)); 
				*hndl_ptr = Timer;
				op_prg_list_insert(HandlesList, hndl_ptr, OPC_LISTPOS_TAIL);
				/*Add timeout estimation record to the list*/
				double_ptr = (double *)op_prg_mem_alloc(sizeof(double)); 
				*double_ptr = op_sim_time();
				op_prg_list_insert(RTTList, double_ptr, OPC_LISTPOS_TAIL);
				//printf("\n NODE %d RTT SMP taken - timestamp:%f! ",op_topo_parent(op_id_self()),*double_ptr);
				}
			else
				{
				op_pk_destroy(tcp_packet_ptr);
				break;
				}
			}
			
		
		}
	else 
		{
		//printf("\n NODE %d send_pkt() - empty queue, timestamp:%f! ",op_topo_parent(op_id_self()),op_sim_time());
		if(next_pkt_type==ACK || next_pkt_type==DUP_PKT_ACK)
			{
			tcp_packet_ptr = op_pk_create_fmt ("pm_utp_packet");
			op_pk_nfd_set (tcp_packet_ptr, "seq_num",TrNextPckSeq);
			op_pk_nfd_set (tcp_packet_ptr, "ack_num",TrNextPckAck);
			op_pk_nfd_set (tcp_packet_ptr, "ack",next_pkt_type);
			op_pk_nfd_set (tcp_packet_ptr, "timestamp",op_sim_time());
			timestamp_difference_send=op_sim_time()-timestamp;
			op_pk_nfd_set (tcp_packet_ptr, "timestamp_difference",timestamp_difference_send);
			//printf("\n NODE %d has sent ACK seq=%d, ack=%d, packet id=%d",op_topo_parent(op_id_self()),TrNextPckSeq, TrNextPckAck,op_pk_id(tcp_packet_ptr));
			op_pk_send(tcp_packet_ptr, TransStream);
			
			next_pkt_type=DATA_PKT;
			}
		}
	FOUT; 
	}



void cancel_timers_utp()
	{
	Evhandle *hndl_ptr;
	FIN(cancel_timers_utp());
	while(op_prg_list_size (HandlesList)!=0)
		{
		hndl_ptr = (Evhandle *)op_prg_list_access(HandlesList, OPC_LISTPOS_HEAD);
		Timer=*hndl_ptr;
		op_ev_cancel_if_pending (Timer);
		op_prg_mem_free(op_prg_list_remove(HandlesList, OPC_LISTPOS_HEAD));
		}
	while(op_prg_list_size (RTTList)!=0)
		{
		op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
		}
	
	FOUT;
	}


void cong_contr_utp(int pkt_size, double queuing_delay)
	{
	double g=0.125,h=0.25,f=8, SERR, granuality=0.1, RTOmin=1.0, RTOmax=3;
	double off_target;
	int increase;
	FIN(cong_contr_utp(pkt_size,queuing_delay));
	
	
	off_target=(TARGET-queuing_delay)/TARGET;
	//printf("\n NODE %d Report, CWND=%d, TARGET=%f, off_target=%f, timestamp_difference=%f, base_delay=%f, queuing_delay=%f", op_topo_parent(op_id_self()),cwnd,TARGET, off_target,timestamp_difference, base_delay, queuing_delay);
	if(cong_flag==SLOW_START)
		{
		cwnd=cwnd_thr_min;
		cong_flag=CONG_AV;
		}
	
	else if(cong_flag==CONG_AV )
		{
		
		increase=pkt_size*MSS/cwnd;
		if(GAIN_NEG_ON==0)
			cwnd=cwnd+(int)(GAIN*off_target*(double)increase);
		else if (GAIN_NEG_ON!=0)
			{
			if(off_target>0)
				cwnd=cwnd+(int)(GAIN_NEG_ON*off_target*(double)increase);
			else
				cwnd=cwnd+(int)(GAIN*off_target*(double)increase);
			}
		if(cwnd<cwnd_thr_min)
			cwnd=cwnd_thr_min;
		}
	//printf("\n NODE %d Report, QSize=%f, cwnd_flag=%d, cwnd=%d,cwnd_thr=%d, timestamp:%f", op_topo_parent(op_id_self()),QSize,cong_flag,cwnd,cwnd_thr,op_sim_time ());
	/*Timer Estimation Function*/
	if(ack_num>=TrWaitAckSeq)
		{
		if(Retr_Cnt_Ack==0)
			{
			RTT=op_sim_time()-RTT;
			op_stat_write (rtt_stat_hndl,RTT);
			//printf("\n NODE %d RTT SMP:%f! ",op_topo_parent(op_id_self()),RTT);
			if(RTT>0.2 || RTT<0.08)
				op_prg_odb_bkpt("SMP_RTT_ERR");
			if(RTT>=SRTT)
				SERR = RTT - SRTT;
			else
				SERR = SRTT - RTT;
		
			SRTT=(1-g)*SRTT+g*RTT;
			SDEV=(1-h)*SDEV+h*SERR;
			if(f*SDEV>granuality)
				TimeOutTimer=SRTT+f*SDEV;
			else
				TimeOutTimer=SRTT+granuality;
			
			}
		
		if(TimeOutTimer<RTOmin)
			TimeOutTimer=RTOmin;
		else if(TimeOutTimer>RTOmax)
			TimeOutTimer=RTOmax;
		
		//printf("\n NODE %d RTT TimeOutTimer:%f, SDEV:%f! ",op_topo_parent(op_id_self()),TimeOutTimer,SDEV);
		
		}
	FOUT;
	}

void cong_contr_tcp()
	{
	double g=0.125,h=0.25,f=8, SERR, granuality=0.1, RTOmin=1.0, RTOmax=3;
	FIN(cong_contr_tcp());
	
	
	if(cong_flag==SLOW_START)
		{
		cwnd=cwnd*2;
		if(cwnd>=cwnd_thr)
			{
			cwnd=cwnd_thr;
			cong_flag=CONG_AV;
			}
		}
	
	else if(cong_flag==CONG_AV )
		{
		cwnd=cwnd+MSS*MSS/cwnd;
		if(cwnd<=0)
			cwnd=cwnd+1;
		}
	//printf("\n NODE %d Report, QSize=%f, cwnd_flag=%d, cwnd=%d,cwnd_thr=%d, timestamp:%f", op_topo_parent(op_id_self()),QSize,cong_flag,cwnd,cwnd_thr,op_sim_time ());
	/*Timer Estimation Function*/
	if(ack_num>=TrWaitAckSeq)
		{
		if(Retr_Cnt_Ack==0)
			{
			RTT=op_sim_time()-RTT;
			op_stat_write (rtt_stat_hndl,RTT);
			//printf("\n NODE %d RTT SMP:%f! ",op_topo_parent(op_id_self()),RTT);
			if(RTT>0.2 || RTT<0.08)
				op_prg_odb_bkpt("SMP_RTT_ERR");
			if(RTT>=SRTT)
				SERR = RTT - SRTT;
			else
				SERR = SRTT - RTT;
		
			SRTT=(1-g)*SRTT+g*RTT;
			SDEV=(1-h)*SDEV+h*SERR;
			if(f*SDEV>granuality)
				TimeOutTimer=SRTT+f*SDEV;
			else
				TimeOutTimer=SRTT+granuality;
			
			}
		
		if(TimeOutTimer<RTOmin)
			TimeOutTimer=RTOmin;
		else if(TimeOutTimer>RTOmax)
			TimeOutTimer=RTOmax;
		
		//printf("\n NODE %d RTT TimeOutTimer:%f, SDEV:%f! ",op_topo_parent(op_id_self()),TimeOutTimer,SDEV);
		
		}
	FOUT;
	}

int sum_compare (const void * aptr, const void * bptr)
		{
		double *asum, *bsum;
		FIN(sum_compare(aptr,bptr))
		asum = (double*)aptr;
		bsum = (double*)bptr;

    	if (*asum > *bsum)        {FRET(1)}
		else if (*asum < *bsum)   {FRET(-1)}
		else                     {FRET(0)}
		}

double FILTER ()
	{
		double g=0.125;
		FIN(FILTER ())

    	if (FILTER_TYPE==0)        
		{
			FRET(timestamp_difference)
		}
		else if (FILTER_TYPE==1)   
		{
			est_timestamp_difference=(1-g)*est_timestamp_difference+g*timestamp_difference;
			FRET(est_timestamp_difference)
		}
		else {FRET(timestamp_difference)}
	}
		

void update_base_delay()
	{
	double *double_ptr;
	double *delay;
	
	FIN(update_base_delay());
	
	if((int)op_sim_time() != (int)last_rollover || init_base_delay==base_delay)
		{
		//printf("\n NODE %d Update base delay with: %f",op_topo_parent(op_id_self()),timestamp_difference);
		last_rollover=op_sim_time();
		if(op_prg_list_size(BaseDelayList)>=10 )
			op_prg_list_remove(BaseDelayList, OPC_LISTPOS_HEAD);
		
		double_ptr = (double *)op_prg_mem_alloc(sizeof(double)); 
		*double_ptr = timestamp_difference;
		op_prg_list_insert(BaseDelayList,double_ptr, OPC_LISTPOS_TAIL);
		/*find minimum*/
		prg_list_sort (BaseDelayList, sum_compare);
		delay=(double *)op_prg_list_access(BaseDelayList, OPC_LISTPOS_TAIL);
		base_delay=*delay;
		}
	else
		{
		if(op_prg_list_size(BaseDelayList)>0 )
			{
			delay=(double *)op_prg_list_access(BaseDelayList, OPC_LISTPOS_TAIL);
			if(*delay>=timestamp_difference)
				{
				base_delay=timestamp_difference;
				}
			else 
				{
				base_delay=*delay;
				}
			}
		}
	
	
	
	
	FOUT;
	}


/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void pm_utp_process (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_pm_utp_process_init (int * init_block_ptr);
	void _op_pm_utp_process_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_pm_utp_process_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_pm_utp_process_alloc (VosT_Obtype, int);
	void _op_pm_utp_process_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
pm_utp_process (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (pm_utp_process ());

		{
		/* Temporary Variables */
		int pkt_type=DATA_PKT,app_data_flag;
		Packet* packet_ptr;
		/* End of Temporary Variables */


		FSM_ENTER ("pm_utp_process")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "INIT", "pm_utp_process [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process [INIT enter execs]", state0_enter_exec)
				{
				/*ID of the connections Incoming*/
				Objid MyID, StrmID, OtherID;
				int index, InStreams,OutStreams;
				char ModuleName[64];
				double* double_ptr;
				MyID = op_id_self();
				
				cong_flag=SLOW_START;
				
				
				op_ima_sim_attr_get (OPC_IMA_DOUBLE, "TARGET", &TARGET);
				op_ima_sim_attr_get (OPC_IMA_DOUBLE, "GAIN", &GAIN);
				op_ima_sim_attr_get (OPC_IMA_INTEGER, "utp_on", &utp_on_hndl);
				op_ima_sim_attr_get (OPC_IMA_INTEGER, "FILTER", &FILTER_TYPE);
				op_ima_sim_attr_get (OPC_IMA_DOUBLE, "GAIN_NEG_ON", &GAIN_NEG_ON);
				if(UTP_ON)
						{
						//printf("\n NODE %d in UTP_ON", op_topo_parent(op_id_self()));
						}
				else if(!UTP_ON) 
						{
						//printf("\n NODE %d in UTP_OFF", op_topo_parent(op_id_self()));
						}
				rtt_stat_hndl   = op_stat_reg ("TCP.RTT",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				retr_hndl   = op_stat_reg ("TCP.Retransmissions",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				one_way_delay_hndl   = op_stat_reg ("TCP.Queue Delay",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				InStreams = op_topo_assoc_count(MyID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STRM);
				OutStreams = op_topo_assoc_count(MyID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_STRM);
				/*Find the Packet and AppData Streams*/
				
				for (index = 0; index < InStreams; index++)
				{
					/*Find the stream index at the specific association*/
					StrmID = op_topo_assoc(MyID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STRM, index);
					
					if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PROC)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PROC,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "Application") == 0)
							{
								op_ima_obj_attr_get(StrmID, "dest stream", &AppDataStream);
							}
					}
					if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PTRX)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_PTRX,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "RX") == 0)
							{
								op_ima_obj_attr_get(StrmID, "dest stream", &PckStream);
							}
					}
				}
				
				for (index = 0; index < OutStreams; index++)
				{
					/*Find the stream index at the specific association*/
					StrmID = op_topo_assoc(MyID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_STRM, index);
					
					if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PROC)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PROC,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "Application") == 0)
							{
								op_ima_obj_attr_get(StrmID, "src stream", &SinkStream);
								printf("SinkStream: %d\n",SinkStream);
							}
					}
					else if(op_topo_assoc_count(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PTTX)!=0)
					{
						/*Find the process index at the specific association*/
						OtherID = op_topo_assoc(StrmID, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PTTX,0);
						/*Access the attribute name and find the proper streams*/
						op_ima_obj_attr_get(OtherID, "name", ModuleName);
						if (strcmp(ModuleName, "TX") == 0)
							{
								op_ima_obj_attr_get(StrmID, "src stream", &TransStream);
								printf("TransStream: %d\n",TransStream);
							}
					}
				}
				
				/*Initialization*/
				app_data_flag=1;
				SRTT=1.0;
				SRTT=0;
				SDEV=0;
				TimeOutTimer=1.0;
				fast_retr_flag=0;
				MSS=1400; //byte
				RecNextPckSeq=0;
				TrNextPckSeq=0;
				TrNextPckAck=0;
				retr_per_pkt=0;
				retr=0;
				cwnd=1*MSS;
				cwnd_thr_min=2*MSS;
				cwnd_thr=cwnd_thr_min;
				cwnd_start_seq=0;
				timestamp=0;
				timestamp_difference=0;
				est_timestamp_difference=0.1;
				init_base_delay=100000;//ms
				base_delay=init_base_delay;
				ack_seq_cnt=0;
				pkts_in_flight=0;
				RTTList= op_prg_list_create();
				HandlesList = op_prg_list_create();
				BaseDelayList= op_prg_list_create();
				CurrentDelayList = op_prg_list_create();
				op_prg_list_init(RTTList);
				op_prg_list_init(HandlesList);
				op_prg_list_init(BaseDelayList);
				op_prg_list_init(CurrentDelayList);
				
				double_ptr = (double *)op_prg_mem_alloc(sizeof(double)); 
				*double_ptr = base_delay;
				op_prg_list_insert(BaseDelayList,double_ptr, OPC_LISTPOS_TAIL);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "INIT", "pm_utp_process [INIT exit execs]")


			/** state (INIT) transition processing **/
			FSM_TRANSIT_ONLY ((PowerUp), 1, state1_enter_exec, ;, INIT, "PowerUp", "", "INIT", "ESTAB", "tr_10", "pm_utp_process [INIT -> ESTAB : PowerUp / ]")
				/*---------------------------------------------------------*/



			/** state (ESTAB) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "ESTAB", state1_enter_exec, "pm_utp_process [ESTAB enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"pm_utp_process")


			/** state (ESTAB) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "ESTAB", "pm_utp_process [ESTAB exit execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process [ESTAB exit execs]", state1_exit_exec)
				{
				if(PacketArrival)
					{
					packet_ptr = op_pk_get(op_intrpt_strm());
					//printf("\n NODE %d PCKT ARRIVAL, size=%d", op_id_self (),op_pk_total_size_get(packet_ptr));
					op_pk_nfd_access (packet_ptr, "ack",&pkt_type);
					op_pk_nfd_access (packet_ptr, "seq_num", &seq);
					op_pk_nfd_access (packet_ptr, "ack_num", &ack_num);
					op_pk_nfd_access (packet_ptr, "timestamp", &timestamp);
					op_pk_nfd_access (packet_ptr, "timestamp_difference", &timestamp_difference);	
					//printf("\n NODE %d Report, timestamp_difference=%f, timestamp=%f", op_topo_parent(op_id_self()),timestamp_difference,timestamp);
					}
				else if(AppDataArrival)
					{
					packet_ptr = op_pk_get(op_intrpt_strm());
					//printf("\n NODE %d APPDATA ARRIVAL, size=%d, timestamp:%f", op_topo_parent(op_id_self()),op_pk_total_size_get(packet_ptr)/8,op_sim_time());
					}
				else  if(TimerOver)
					{
					//printf("\n NODE %d TimerOver, timestamp:%f", op_id_self (),op_sim_time () );
					}
				else 
					printf("\n NODE %d WTF", op_topo_parent(op_id_self()));
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (ESTAB) transition processing **/
			FSM_PROFILE_SECTION_IN ("pm_utp_process [ESTAB trans conditions]", state1_trans_conds)
			FSM_INIT_COND (AppDataArrival)
			FSM_TEST_COND (PacketArrival)
			FSM_TEST_COND (TimerOver)
			FSM_TEST_LOGIC ("ESTAB")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "AppDataArrival", "", "ESTAB", "AppData_HNDL", "tr_12", "pm_utp_process [ESTAB -> AppData_HNDL : AppDataArrival / ]")
				FSM_CASE_TRANSIT (1, 5, state5_enter_exec, ;, "PacketArrival", "", "ESTAB", "Pkt_hndl", "tr_23", "pm_utp_process [ESTAB -> Pkt_hndl : PacketArrival / ]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "TimerOver", "", "ESTAB", "Retr_hndl", "tr_27", "pm_utp_process [ESTAB -> Retr_hndl : TimerOver / ]")
				}
				/*---------------------------------------------------------*/



			/** state (AppData_HNDL) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "AppData_HNDL", state2_enter_exec, "pm_utp_process [AppData_HNDL enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process [AppData_HNDL enter execs]", state2_enter_exec)
				{
				Packet* tcp_packet_ptr;
				tcp_packet_ptr = op_pk_create_fmt ("pm_utp_packet");
				op_pk_nfd_set_pkt (tcp_packet_ptr, "data_field", packet_ptr);
				/*Copy pkt and queue it*/
				app_data_flag=1;
				if(op_subq_pk_insert(0, tcp_packet_ptr, OPC_QPOS_TAIL)!= OPC_QINS_OK)
					{
					op_pk_destroy(tcp_packet_ptr);
					//printf("\n Packet not queued");
					app_data_flag=0;
					}
					
				next_pkt_type=DATA_PKT;	
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (AppData_HNDL) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "AppData_HNDL", "pm_utp_process [AppData_HNDL exit execs]")


			/** state (AppData_HNDL) transition processing **/
			FSM_PROFILE_SECTION_IN ("pm_utp_process [AppData_HNDL trans conditions]", state2_trans_conds)
			FSM_INIT_COND (!AppDestroyed)
			FSM_TEST_COND (AppDestroyed)
			FSM_TEST_LOGIC ("AppData_HNDL")
			FSM_PROFILE_SECTION_OUT (state2_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, send_pkt_utp();, "!AppDestroyed", "send_pkt_utp()", "AppData_HNDL", "ESTAB", "tr_18", "pm_utp_process [AppData_HNDL -> ESTAB : !AppDestroyed / send_pkt_utp()]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, ;, "AppDestroyed", "", "AppData_HNDL", "ESTAB", "tr_30", "pm_utp_process [AppData_HNDL -> ESTAB : AppDestroyed / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Ack_HNDL) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "Ack_HNDL", state3_enter_exec, "pm_utp_process [Ack_HNDL enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process [Ack_HNDL enter execs]", state3_enter_exec)
				{
				Packet* queue_packet_ptr;
				Evhandle *hndl_ptr;
				double *double_ptr;
				double queuing_delay;
				int i,n,pkt_size;
				/*ACK is proper*/
				
				if(ack_num==TrWaitAckSeq)
					{
					//printf("\n NODE %d has received ACK packet, ack=%d, ExpecAck=%d, timestamp:%f", op_topo_parent(op_id_self()),ack_num,TrWaitAckSeq,op_sim_time());
					op_prg_odb_bkpt("ACK_TCP");
					/****Congestion window deflation for fast retransmit****/
					if(fast_retr_flag==1)
						{
						cwnd=cwnd_thr;
						fast_retr_flag=0;
						}
					/*Upade the statistics*/
					op_stat_write (retr_hndl,retr=retr+retr_per_pkt/550);
					retr_per_pkt=0;
					
					
					/*Removing copy of the acknowledged packet from the proper queue and destroying*/
					if(!op_subq_empty(0))
						{
						queue_packet_ptr = op_subq_pk_remove (0, OPC_QPOS_HEAD);
						pkt_size=op_pk_total_size_get(queue_packet_ptr)/8;
						//printf("\n NODE %d remove and destroy packet from the queue, pkt size=%d", op_topo_parent(op_id_self()),pkt_size);
						op_pk_destroy (queue_packet_ptr);
						hndl_ptr = (Evhandle *)op_prg_list_access(HandlesList, OPC_LISTPOS_HEAD);
						Timer=*hndl_ptr;
						op_ev_cancel(Timer);
						op_prg_mem_free(op_prg_list_remove(HandlesList, OPC_LISTPOS_HEAD));
						/*Update sliding window, parameters and doubled acks stat*/
						cwnd_start_seq=TrWaitAckSeq;
					
						if(pkts_in_flight!=0)
							{
							pkts_in_flight--;
							}
					
						/*Update Sample RTT value*****************************************/
						if(op_prg_list_size (RTTList)!=0)
								{
								double_ptr = (double *)op_prg_list_access(RTTList, OPC_LISTPOS_HEAD);
								RTT=*double_ptr;
								//printf("\n NODE %d received ack, cwnd_start_seq=%d, RTT=%f", op_topo_parent(op_id_self()),cwnd_start_seq,RTT);
								op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
								}
						/*****************************************************************/
						ack_seq_cnt=0;
						//TrNextPckAck=seq;
						op_pk_destroy(packet_ptr);
						
						/*queueing delay estimation*/
						update_base_delay();
						queuing_delay=(FILTER()-base_delay)*1000;
						/********************/
						if(UTP_ON)
							{
							cong_contr_utp(pkt_size,queuing_delay);
							}
						else if(!UTP_ON) 
							{
							cong_contr_tcp();
							}
						op_stat_write (one_way_delay_hndl,queuing_delay);
					
						if(Retr_Cnt_Ack!=0)
							{
							Retr_Cnt_Ack=Retr_Cnt_Ack-pkt_size;
							//printf("\n NODE %d has received ACK packet, Retr_Cnt_Ack=%d, timestamp:%f", op_topo_parent(op_id_self()),Retr_Cnt_Ack,op_sim_time());
							}
						}
						
					else
						{
						/*doubled ack*/
						}
					/*update TrNextPckSeq after correct ack ending retransmission before acks from retr packets*/
					if(TrNextPckSeq<cwnd_start_seq)
						{
						TrNextPckSeq=ack_num;
						}
					}
					/*ACK is not proper*/
				else if(ack_num>TrWaitAckSeq)
					{
					//printf("\n NODE %d CUMULATIVE ACK packet, ack=%d, ExpecAck=%d, timestamp:%f, packet id=%d", op_topo_parent(op_id_self()),ack_num,TrWaitAckSeq,op_sim_time(),op_pk_id(packet_ptr));
					/****Congestion window deflation for fast retransmit****/
					if(fast_retr_flag==1)
						{
						cwnd=cwnd_thr;
						fast_retr_flag=0;
						}
					/*Upade the statistics*/
					op_stat_write (retr_hndl,retr=retr+retr_per_pkt/550);
					retr_per_pkt=0;	
					
					/*Removing copy of the acknowledged packet from the proper queue and destroying*/
					i=TrWaitAckSeq;
					
					do
						{
						if(op_prg_list_size (HandlesList)!=0)
							{
							hndl_ptr = (Evhandle *)op_prg_list_access(HandlesList, OPC_LISTPOS_HEAD);
							Timer=*hndl_ptr;
							op_ev_cancel(Timer);
							op_prg_mem_free(op_prg_list_remove(HandlesList, OPC_LISTPOS_HEAD));
							}
						queue_packet_ptr = op_subq_pk_remove (0, OPC_QPOS_HEAD);
						pkt_size=op_pk_total_size_get(queue_packet_ptr)/8;
						op_pk_destroy (queue_packet_ptr);
						//printf("\n NODE %d remove and destroy packet from the queue, i=%d,pkt size=%d", op_topo_parent(op_id_self()),i,pkt_size);
						if(pkts_in_flight!=0)
							{
							pkts_in_flight--;
							}
						if(Retr_Cnt_Ack!=0)
							{
							Retr_Cnt_Ack=Retr_Cnt_Ack-pkt_size;
							}
						
						/*Update Sample RTT value*****************************************/
						if(op_prg_list_size (RTTList)!=0)
							{
							if(i==ack_num)
								{
								double_ptr = (double *)op_prg_list_access(RTTList, OPC_LISTPOS_HEAD);
								RTT=*double_ptr;
								//printf("\n NODE %d CUMMULATIVE ACK, RTT=%f", op_topo_parent(op_id_self()),op_sim_time()-RTT);
								}
							op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
						/*****************************************************************/
							}
						if(i!=ack_num)
								{
								queue_packet_ptr = op_subq_pk_access (0, OPC_QPOS_HEAD);
								pkt_size=op_pk_total_size_get(queue_packet_ptr)/8;
								i=i+pkt_size;
								}
						else
							{
							i++;
							}
						//printf("\n NODE %d i=%d,pkt size=%d", op_topo_parent(op_id_self()),i,pkt_size);
						}while(i<=ack_num);
					
					/*Update sliding window, parameters and doubled acks stat*/
					cwnd_start_seq=ack_num;
					TrWaitAckSeq=ack_num;
					ack_seq_cnt=0;
					//TrNextPckAck=seq;
					/*update TrNextPckSeq */
					if(TrNextPckSeq<cwnd_start_seq)
						{
						TrNextPckSeq=ack_num;
						}
					//printf("\n NODE %d destroy ack", op_id_self ());
					op_pk_destroy(packet_ptr);
					
					
					update_base_delay();
					queuing_delay=(timestamp_difference-base_delay)*1000;
					
					if(UTP_ON)
						{
						cong_contr_utp(pkt_size,queuing_delay);
						}
					else if(!UTP_ON) 
						{
						cong_contr_tcp();
						}
					op_stat_write (one_way_delay_hndl,queuing_delay);
					
					op_prg_odb_bkpt("C_ACK_TCP");
					}
				else if(ack_num<TrWaitAckSeq)
					{
					//printf("\n NODE %d DUPLICATE ACK packet tpe=%d, ack=%d, ExpecAck=%d, timestamp:%f, pkt_id=%d", op_topo_parent(op_id_self()),pkt_type,ack_num,TrWaitAckSeq,op_sim_time(),op_pk_id(packet_ptr));
					op_prg_odb_bkpt("DUPACK_TCP");
					/****Congestion window inflation for fast retransmit****/
					if(fast_retr_flag==1)
						{
						cwnd=cwnd+MSS;
						if(ack_num==cwnd_start_seq)
							ack_seq_cnt--;
						}
					
					if(pkt_type==ACK)
						{
						ack_seq_cnt++;
						}
					else if(pkt_type==DUP_PKT_ACK)
						{
						op_prg_odb_bkpt("DUP_PKT_ACK_TCP");
						}
					
					op_pk_destroy(packet_ptr);
					/*Update Sample RTT value*/
					i=ack_num;
					n=0;
					if(Retr_Cnt_Ack==0)
						{
						while(i!=TrWaitAckSeq)
							{
							queue_packet_ptr = op_subq_pk_access (0, n);
							pkt_size=op_pk_total_size_get(queue_packet_ptr)/8;
							n++;
							i=i+pkt_size;
							}
						i=n;
						while(i==0)
							{
							if(i<=op_prg_list_size (RTTList))
								{
								if(op_prg_list_size (RTTList)!=0)
									{
									double_ptr = (double *)op_prg_list_access(RTTList, i);
									//printf("\n NODE %d DUPLICATE ACK, RTT=%f", op_topo_parent(op_id_self()),*double_ptr);
									op_prg_mem_free(op_prg_list_remove(RTTList, OPC_LISTPOS_HEAD));
									}
								}
							i--;
							}
						}
					
					}
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (Ack_HNDL) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "Ack_HNDL", "pm_utp_process [Ack_HNDL exit execs]")


			/** state (Ack_HNDL) transition processing **/
			FSM_PROFILE_SECTION_IN ("pm_utp_process [Ack_HNDL trans conditions]", state3_trans_conds)
			FSM_INIT_COND (FastRetrans)
			FSM_TEST_COND (ack_num>=TrWaitAckSeq  && ack_seq_cnt<4)
			FSM_TEST_COND (ack_num<TrWaitAckSeq  && ack_seq_cnt<4)
			FSM_TEST_LOGIC ("Ack_HNDL")
			FSM_PROFILE_SECTION_OUT (state3_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 4, state4_enter_exec, ;, "FastRetrans", "", "Ack_HNDL", "Retr_hndl", "tr_19", "pm_utp_process [Ack_HNDL -> Retr_hndl : FastRetrans / ]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, send_pkt_utp();, "ack_num>=TrWaitAckSeq  && ack_seq_cnt<4", "send_pkt_utp()", "Ack_HNDL", "ESTAB", "tr_21", "pm_utp_process [Ack_HNDL -> ESTAB : ack_num>=TrWaitAckSeq  && ack_seq_cnt<4 / send_pkt_utp()]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "ack_num<TrWaitAckSeq  && ack_seq_cnt<4", "", "Ack_HNDL", "ESTAB", "tr_29", "pm_utp_process [Ack_HNDL -> ESTAB : ack_num<TrWaitAckSeq  && ack_seq_cnt<4 / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Retr_hndl) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "Retr_hndl", state4_enter_exec, "pm_utp_process [Retr_hndl enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process [Retr_hndl enter execs]", state4_enter_exec)
				{
				if(TimerOver)
					{
					//printf("\n NODE %d Timerover, TrNextPckSeq=%d,cwnd_start_seq=%d", op_topo_parent(op_id_self()),TrNextPckSeq,cwnd_start_seq);
					Retr_Cnt_Ack=TrNextPckSeq-cwnd_start_seq;
					TimeOutTimer=TimeOutTimer*2;
					ack_seq_cnt=0;
					cancel_timers_utp();
					pkts_in_flight=0;
					retr_per_pkt=retr_per_pkt+Retr_Cnt_Ack;
					TrNextPckSeq=cwnd_start_seq;
					if(cwnd/2>=MSS)
						{
						cwnd_thr=cwnd/2;
						cwnd=MSS;
						cong_flag=SLOW_START;
						}
					else
						{
						cwnd_thr=MSS;
						cwnd=MSS;
						cong_flag=CONG_AV;
						}
					//printf("\n NODE %d Timerover, timestamp:%f, Retr_Cnt_Ack=%f, cong_flag=%d, cwnd=%d, pkts_in_flight=%d, TrNextPckSeq=%d, cwnd_start_seq=%d", op_topo_parent(op_id_self()),op_sim_time(),Retr_Cnt_Ack, cong_flag, cwnd, pkts_in_flight, TrNextPckSeq, cwnd_start_seq);
					op_prg_odb_bkpt("RETR_TCP");
					}
				else if (FastRetrans)
					{
					//printf("\n NODE %d FastRetr, TrNextPckSeq=%d,cwnd_start_seq=%d", op_topo_parent(op_id_self()),TrNextPckSeq,cwnd_start_seq);
					Retr_Cnt_Ack=TrNextPckSeq-cwnd_start_seq;
						
					fast_retr_flag=1;
					cancel_timers_utp();
					ack_seq_cnt=0;
					pkts_in_flight=0;
					retr_per_pkt=retr_per_pkt+Retr_Cnt_Ack;
					TrNextPckSeq=cwnd_start_seq;
					if(cwnd/2>=2*MSS)
						{
						cwnd_thr=cwnd/2;
						}
					else
						{
						cwnd_thr=2*MSS;
						}
					cwnd=cwnd_thr+3*MSS;
					cong_flag=CONG_AV;
					//printf("\n NODE %d FastRetr, timestamp:%f, Retr_Cnt_Ack=%f, cwnd_flag=%d, cwnd=%d, pkts_in_flight=%d, TrNextPckSeq=%d, cwnd_start_seq=%d", op_topo_parent(op_id_self()),op_sim_time(),Retr_Cnt_Ack, cong_flag, cwnd, pkts_in_flight, TrNextPckSeq, cwnd_start_seq);
					op_prg_odb_bkpt("FAST_RETR_TCP");
					}
				
				if(cwnd<=0)
					op_prg_odb_bkpt("LOG_CWND_ERR");
				//printf("\n NODE %d Report, cwnd_flag=%d, cwnd=%d,cwnd_thr=%d, timestamp:%f", op_topo_parent(op_id_self()),cong_flag,cwnd,cwnd_thr,op_sim_time ());
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (Retr_hndl) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "Retr_hndl", "pm_utp_process [Retr_hndl exit execs]")


			/** state (Retr_hndl) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, send_pkt_utp();, "default", "send_pkt_utp()", "Retr_hndl", "ESTAB", "tr_20", "pm_utp_process [Retr_hndl -> ESTAB : default / send_pkt_utp()]")
				/*---------------------------------------------------------*/



			/** state (Pkt_hndl) enter executives **/
			FSM_STATE_ENTER_FORCED (5, "Pkt_hndl", state5_enter_exec, "pm_utp_process [Pkt_hndl enter execs]")
				FSM_PROFILE_SECTION_IN ("pm_utp_process [Pkt_hndl enter execs]", state5_enter_exec)
				{
				/*Data packet arrival*/
				Packet* app_packet_ptr;
				int pkt_size;
				double cr_time;
				
				//printf("\n NODE %d PktArr of type=%d, seq=%d, Exp seq=%d", op_topo_parent(op_id_self()),pkt_type,seq,RecNextPckSeq);
				if (op_pk_nfd_is_set (packet_ptr, "data_field"))
					{
					
					if(seq==RecNextPckSeq)
						{
						op_pk_nfd_get_pkt (packet_ptr, "data_field", &app_packet_ptr);
						pkt_size=op_pk_total_size_get(app_packet_ptr)/8;
						//printf("\n NODE %d PktArr D%d, s%d, Exp seq=%d, a%d,Exp ack=%d packet id=%d", op_topo_parent(op_id_self()),pkt_size,seq,RecNextPckSeq,ack_num,TrWaitAckSeq,op_pk_id(packet_ptr));
						cr_time=op_pk_creation_time_get (app_packet_ptr);
						op_pk_send(app_packet_ptr, SinkStream);
						RecNextPckSeq=RecNextPckSeq+pkt_size;
						//printf("\n NODE %d Destroying packet", op_topo_parent(op_id_self()));
					
						TrNextPckAck=RecNextPckSeq;
						//printf("\n NODE %d DataPktArr of size=%d, timestamp: %f, creation:%f", op_topo_parent(op_id_self()),pkt_size,op_sim_time(),cr_time);
						next_pkt_type=ACK;
						}
					else if(seq<RecNextPckSeq)
						{
						op_prg_odb_bkpt("DUP_PKT");
						op_pk_nfd_get_pkt (packet_ptr, "data_field", &app_packet_ptr);
						pkt_size=op_pk_total_size_get(app_packet_ptr)/8;
						//printf("\n NODE %d DUPLICATE PktArr D%d, s%d, a%d, Exp seq=%d packet id=%d", op_topo_parent(op_id_self()),pkt_size,seq,ack_num,RecNextPckSeq,op_pk_id(packet_ptr));
						op_pk_destroy (app_packet_ptr);
						TrNextPckAck=RecNextPckSeq;	
						//printf("\n NODE %d DataPktArr of size=%d, timestamp: %f", op_topo_parent(op_id_self()),pkt_size,op_sim_time());
						//printf("\n NODE %d Destroying packet", op_topo_parent(op_id_self()));
								
						next_pkt_type=DUP_PKT_ACK;
						}
					else
						{
						op_prg_odb_bkpt("WR_PKT");
						//printf("\n NODE %d WRONG PktArr s%d, a%d, Exp seq=%d packet id=%d", op_topo_parent(op_id_self()),seq,ack_num,RecNextPckSeq,op_pk_id(packet_ptr));
						//printf("\n NODE %d Destroying packet", op_topo_parent(op_id_self()));
						TrNextPckAck=RecNextPckSeq;
						next_pkt_type=ACK;
						}
					}
				else
					{
					//printf("\n NODE %d PktArr ACK, s%d, Exp seq=%d, a%d,Exp ack=%d", op_topo_parent(op_id_self()),seq,RecNextPckSeq,ack_num,TrWaitAckSeq);
					}
				if(DataPacketArrival)
					op_pk_destroy(packet_ptr);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** state (Pkt_hndl) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "Pkt_hndl", "pm_utp_process [Pkt_hndl exit execs]")


			/** state (Pkt_hndl) transition processing **/
			FSM_PROFILE_SECTION_IN ("pm_utp_process [Pkt_hndl trans conditions]", state5_trans_conds)
			FSM_INIT_COND (DataPacketArrival)
			FSM_TEST_COND (AckPacketArrival)
			FSM_TEST_LOGIC ("Pkt_hndl")
			FSM_PROFILE_SECTION_OUT (state5_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, send_pkt_utp();, "DataPacketArrival", "send_pkt_utp()", "Pkt_hndl", "ESTAB", "tr_24", "pm_utp_process [Pkt_hndl -> ESTAB : DataPacketArrival / send_pkt_utp()]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "AckPacketArrival", "", "Pkt_hndl", "Ack_HNDL", "tr_28", "pm_utp_process [Pkt_hndl -> Ack_HNDL : AckPacketArrival / ]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"pm_utp_process")
		}
	}




void
_op_pm_utp_process_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_pm_utp_process_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_pm_utp_process_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_pm_utp_process_svar function. */
#undef PckStream
#undef AppDataStream
#undef SinkStream
#undef TransStream
#undef RecNextPckSeq
#undef TrNextPckSeq
#undef TrWaitAckSeq
#undef rtt_stat_hndl
#undef retr_per_pkt
#undef TimeOutTimer
#undef Timer
#undef DataPktArr
#undef TrPckSeq
#undef retr_hndl
#undef retr
#undef TrNextPckAck
#undef TrPckAck
#undef cwnd
#undef cwnd_start_seq
#undef ack_seq_cnt
#undef HandlesList
#undef RecNextAckNum
#undef MSS
#undef pkts_in_flight
#undef cwnd_thr
#undef cong_flag
#undef SRTT
#undef RTT
#undef SDEV
#undef RTTList
#undef Retr_Cnt_Ack
#undef fast_retr_flag
#undef next_pkt_type
#undef ack_num
#undef seq
#undef timestamp
#undef one_way_delay_hndl
#undef cwnd_thr_min
#undef timestamp_difference
#undef FILTER_TYPE
#undef TARGET
#undef GAIN
#undef base_delay
#undef BaseDelayList
#undef CurrentDelayList
#undef utp_on_hndl
#undef last_rollover
#undef init_base_delay
#undef est_timestamp_difference
#undef GAIN_NEG_ON

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_pm_utp_process_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_pm_utp_process_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (pm_utp_process)",
		sizeof (pm_utp_process_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_pm_utp_process_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	pm_utp_process_state * ptr;
	FIN_MT (_op_pm_utp_process_alloc (obtype))

	ptr = (pm_utp_process_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "pm_utp_process [INIT enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_pm_utp_process_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	pm_utp_process_state		*prs_ptr;

	FIN_MT (_op_pm_utp_process_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (pm_utp_process_state *)gen_ptr;

	if (strcmp ("PckStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->PckStream);
		FOUT
		}
	if (strcmp ("AppDataStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->AppDataStream);
		FOUT
		}
	if (strcmp ("SinkStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SinkStream);
		FOUT
		}
	if (strcmp ("TransStream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TransStream);
		FOUT
		}
	if (strcmp ("RecNextPckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RecNextPckSeq);
		FOUT
		}
	if (strcmp ("TrNextPckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrNextPckSeq);
		FOUT
		}
	if (strcmp ("TrWaitAckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrWaitAckSeq);
		FOUT
		}
	if (strcmp ("rtt_stat_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rtt_stat_hndl);
		FOUT
		}
	if (strcmp ("retr_per_pkt" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retr_per_pkt);
		FOUT
		}
	if (strcmp ("TimeOutTimer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TimeOutTimer);
		FOUT
		}
	if (strcmp ("Timer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Timer);
		FOUT
		}
	if (strcmp ("DataPktArr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DataPktArr);
		FOUT
		}
	if (strcmp ("TrPckSeq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrPckSeq);
		FOUT
		}
	if (strcmp ("retr_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retr_hndl);
		FOUT
		}
	if (strcmp ("retr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retr);
		FOUT
		}
	if (strcmp ("TrNextPckAck" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrNextPckAck);
		FOUT
		}
	if (strcmp ("TrPckAck" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TrPckAck);
		FOUT
		}
	if (strcmp ("cwnd" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd);
		FOUT
		}
	if (strcmp ("cwnd_start_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd_start_seq);
		FOUT
		}
	if (strcmp ("ack_seq_cnt" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_seq_cnt);
		FOUT
		}
	if (strcmp ("HandlesList" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->HandlesList);
		FOUT
		}
	if (strcmp ("RecNextAckNum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RecNextAckNum);
		FOUT
		}
	if (strcmp ("MSS" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->MSS);
		FOUT
		}
	if (strcmp ("pkts_in_flight" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_in_flight);
		FOUT
		}
	if (strcmp ("cwnd_thr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd_thr);
		FOUT
		}
	if (strcmp ("cong_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cong_flag);
		FOUT
		}
	if (strcmp ("SRTT" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SRTT);
		FOUT
		}
	if (strcmp ("RTT" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RTT);
		FOUT
		}
	if (strcmp ("SDEV" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SDEV);
		FOUT
		}
	if (strcmp ("RTTList" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->RTTList);
		FOUT
		}
	if (strcmp ("Retr_Cnt_Ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Retr_Cnt_Ack);
		FOUT
		}
	if (strcmp ("fast_retr_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fast_retr_flag);
		FOUT
		}
	if (strcmp ("next_pkt_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->next_pkt_type);
		FOUT
		}
	if (strcmp ("ack_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_num);
		FOUT
		}
	if (strcmp ("seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->seq);
		FOUT
		}
	if (strcmp ("timestamp" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->timestamp);
		FOUT
		}
	if (strcmp ("one_way_delay_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->one_way_delay_hndl);
		FOUT
		}
	if (strcmp ("cwnd_thr_min" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cwnd_thr_min);
		FOUT
		}
	if (strcmp ("timestamp_difference" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->timestamp_difference);
		FOUT
		}
	if (strcmp ("FILTER_TYPE" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->FILTER_TYPE);
		FOUT
		}
	if (strcmp ("TARGET" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TARGET);
		FOUT
		}
	if (strcmp ("GAIN" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GAIN);
		FOUT
		}
	if (strcmp ("base_delay" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->base_delay);
		FOUT
		}
	if (strcmp ("BaseDelayList" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->BaseDelayList);
		FOUT
		}
	if (strcmp ("CurrentDelayList" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CurrentDelayList);
		FOUT
		}
	if (strcmp ("utp_on_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->utp_on_hndl);
		FOUT
		}
	if (strcmp ("last_rollover" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_rollover);
		FOUT
		}
	if (strcmp ("init_base_delay" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->init_base_delay);
		FOUT
		}
	if (strcmp ("est_timestamp_difference" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->est_timestamp_difference);
		FOUT
		}
	if (strcmp ("GAIN_NEG_ON" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GAIN_NEG_ON);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

